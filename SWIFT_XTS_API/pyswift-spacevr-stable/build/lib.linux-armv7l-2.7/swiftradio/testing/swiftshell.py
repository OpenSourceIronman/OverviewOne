#!/usr/bin/env python
"""
Shell Program for sending/receiving cmdhost commands using the SWIFT RPC protocol.
"""
import sys
import time
import logging
import argparse
import traceback
sys.path.insert(1, "../..")
sys.path.insert(2, "../../Packages")
import swiftradio
from swiftradio.clients import SwiftRadioEthernet, SwiftRadioRS422

__author__ = "Steve Alvarado"
__email__ = "alvarado@tethers.com"
__company__ = "Tethers Unlimited Inc."
__status__ = "Development"
__date__ = "created: 05/06/16"
__version__ = '0.1'

def print_execution_summary(command_data, output_name=None, dtype='raw', rpc_code=None):
	"""
	Description:
	Parameters:
	Return:
	"""
	cmderr_val = None
	data_pkts_rcvd = 0
	status_pkts_rcvd = 0
	error_list = list()
	invparam_error_msgs = {	2:"Required parameter value missing",
							3:"Parameter value formatted incorrectly according to parameter type",
						 	4:"Parameter value unknown relative to definition. (i.e. undefined stropt)",
						 	5:"Parameter value is less than the required minimum value",
						 	6:"Parameter value is greater than the required maximum value"}

	data_found = False

	# print "\n[Received Data]"
	# print return error

	# display any error codes generated by the command execution
	if command_data["_error"] is not None:

		# iterate through error_list and print error info for each item in list
		error_code = command_data["_error"]["code"]
		error_type = command_data["_error"]["type"]
		if error_code == -999:
			error_type = "timeout"
		if type(error_type) is str:
			error_type = error_type.upper()
		if error_code == -1 and error_type == "CMDERR":
			print "**unknown command**"
		else:
			print "{} Error".format(error_type)
			if error_code in invparam_error_msgs:
				print "code = {} ({})".format( error_code, invparam_error_msgs[error_code] )
			else:
				print "code = {}".format(error_code)

	else:
		if rpc_code is not None:
			if rpc_code != 0:
				print "return code->{}".format(rpc_code)
				if len(command_data) > 1:
					print ""

		# print only command data specified
		if output_name is not None:
			data = swiftradio.tools.find_command_data_by_name(command_data, output_name, dtype, all_matches=True)
			if data is not None:
				if type(data) is list:
					for data_item in data:
						print "{} = {}".format(output_name, data_item)
				else:
					print "{} = {}".format(output_name, data)
				data_found = True

		# print all command data
		else:
			for name, data in command_data.items():

				# the print tag will be command data hash
				if name != "_error":
					if type(data) is list:
						for data_item in data:
							if type(name) is str:
								print "{} = {}".format(name, data_item)
							else:
								formatted_data = swiftradio.tools.convert_raw(data_item, dtype)
								print "0x{}: {}".format(hex(name)[2:].upper().zfill(4), formatted_data)
					else:
						if type(name) is str:
							print "{} = {}".format(name, data)
						else:
							formatted_data = swiftradio.tools.convert_raw(data, dtype)
							print "0x{}: {}".format(hex(name)[2:].upper().zfill(4), formatted_data)

					data_found = True

def parse_swiftshell_args(command):
	"""
	Description:
	Parameters:
	Return:
	"""
	class SwiftShellCommandParser(argparse.ArgumentParser):
		"""
		Description: A subclass of the argparse ArgumentParser module modified
					 to provide services specific to the swiftradio Library
		"""
		def error(self, message):
			raise SwiftShellCommandParserError(message)


	class SwiftShellCommandParserError(Exception):
		"""
		Description:
		Parameters:
		Return:
		"""
		def __init__(self, message):
			self.message = message

		def get_error_msg(self, added_info = None):
			error_msg = "SwiftShellParserError: " + str(self.message)
			# if added_info != None:
			# 	error_msg += "\n\n-Additional Info- \n\n" + str(added_info)

			return error_msg

	CPREFIX = "%"
	swiftshell = SwiftShellCommandParser(add_help=False, prefix_chars=CPREFIX)
	swiftshell.add_argument("command", type=str, nargs='+',
						help = "name of command to cache (i.e. 'rxdis')")
	swiftshell.add_argument("%n", "%%output_name", type=str,
						help = "name of any command output data. (only data corresponding to this name will be displayed)")
	swiftshell.add_argument("%z", "%%output_dtype", type=str, default="raw", choices=["uint", "int", "float", "string", "str", "raw"],
						help = "format to display received command data")
	swiftshell.add_argument("%o", "%%timeout", type=int, default = 5, choices=range(0, 120), metavar = "TIMEOUTSECS",
							help = "command timeout in seconds. (defaults to 5 seconds)")
	try:
		sh_args = swiftshell.parse_args( command.split(" ") )
	except SwiftShellCommandParserError, error:
		parser_error = error.get_error_msg(added_info = swiftshell.format_help())
		print parser_error
		return None

	if type(sh_args.command ) is list:
		sh_args.command = " ".join(sh_args.command)

	return sh_args

def main():
	try:
		radio = None
		EXIT_COMMANDS = ['%exit', '%x']

		# define command line arguments
		parser = argparse.ArgumentParser(add_help=True)
		parser.add_argument("-i", "--ip", type=str,
							help = "IPv4 ip address of the radio to connect to (setting this will bypass the Network Discover function)")
		parser.add_argument("-p", "--serial_port", help = "COM port number (Windows) or Serial Device path (Linux)")
		parser.add_argument("-t", "--trace", type=int, default=0, choices=[0,1,2,3,4], metavar="TRACELEVEL",
							help = "sets trace level for outputting SwiftRadio actions")
		args = parser.parse_args()

		if args.ip:
			radio = SwiftRadioEthernet(args.ip, trace=args.trace )			# internal instance trace level for debugging
		elif args.serial_port:
			radio = SwiftRadioRS422(args.serial_port, trace = args.trace )	# internal instance trace level for debugging
		else:
			raise RuntimeError("Please specify an IP address (--ip/-i) or Serial Port (--serial_port/-p).")

		print "--"
		print "SwiftShell"
		print "Version {} (beta)".format(__version__)
		print "Tethers Unlimited Inc. (c)"

		print "\n==============================="
		print "  RPC Command Shell"
		print "==============================="

		if radio.connect():

			print "\n[type '{}' or '{}' to quit program]\n".format(EXIT_COMMANDS[0], EXIT_COMMANDS[1])

			user_input = raw_input( "$ " )

			while user_input not in EXIT_COMMANDS:

				# parse special arguments
				sh_args = parse_swiftshell_args(user_input)

				if sh_args is not None:

					command = sh_args.command
					# send command
					try:
						exe_data, error_code = radio.execute_command( command, timeout=sh_args.timeout, return_rpc_error=True )
						# print returned data
						print_execution_summary(exe_data, sh_args.output_name, sh_args.output_dtype, error_code)
						print ""

					except swiftradio.SwiftRadioError,e:
						if " " in command:
							print "\nInvalid Syntax: {}\n".format( command.split(" ")[0] )
						else:
							print "\nInvalid Syntax: {}\n".format( command )
						print e.arg
					except:
						traceback.print_exc()
						print ""

				user_input = raw_input( "$ " )
		else:
			print "**could not connect to radio***"

	except KeyboardInterrupt:
		print "\n**Keyboard Interrupt Detected**\n"
		if(radio != None):
			radio.disconnect()

	except:
		traceback.print_exc()

	print "--"
	if(radio != None):
		radio.disconnect()

	print "\nexiting program...\n"

if __name__ == "__main__":
	main()
